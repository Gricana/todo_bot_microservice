# Telegram bot для управления задачами

## Описание
Этот сервис представляет собой Telegram-бота, 
который позволяет пользователям управлять своими задачами 
и оставлять комментарии к ним. 

Бот взаимодействует с микросервисами [todo_api](https://github.com/Gricana/todo_bot_microservice/tree/main/todo_api) 
и [comments_api](https://github.com/Gricana/todo_bot_microservice/tree/main/comments_api) для выполнения соответствующих операций.

## Технологии

* _**Python 3.13**_
* **_Aiogram_**
* **_Aiogram-dialog_**
* _**Redis**_
* **_Docker_**

## Архитектура проекта

* **dialogs/** - содержит сценарии диалогов бота.
* **handlers/** - обработчики команд и сообщений.
* **services/** - модули для взаимодействия с внешними API и бизнес-логика, 
  обработка ошибок API.
* **states/** - управление состояниями пользователей при выполнении 
  операций над задачами / комментариями.
* **utils/** - вспомогательные модули. В основе, для конвертирования данных 
  API в _human-readable_ формат.
* **infra/** - инфраструктура для подготовки и деплоя бота в docker-compose

## Инструкция по запуску

1. Клонирование всего репозитория и переход в корневую директорию проекта
    ```bash 
       git clone https://github.com/Gricana/todo_bot_microservice.git && cd todo_bot_microservice
    ```

2. Настройка переменных окружения
   
    Перейдите в файл [bot.env](https://github.com/Gricana/todo_bot_microservice/blob/main/bot/infra/bot/bot.env) и 
   укажите [токен](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/infra/bot/bot.env#L8) 
    и [ник](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/infra/bot/bot.env#L9) бота, которые Вы указали в [@BotFather](https://t.me/BotFather):

    ```bash 
    BOT_TOKEN=<токен_Telegram-бота>
    BOT_USERNAME=<your_telegram_bot_username>
    ```
3. Запуск через Docker Compose

   Убедитесь, что у вас установлены Docker и Docker Compose, и Вы 
   находитесь **в корневой директории проекта**. 
   Затем выполните команду:

    ```bash
    docker-compose -f bot/infra/docker/docker-compose.bot.yml up -d
    ```

    Это поднимет бот и Redis.

## Трудности и их решения

1. **Обработка ошибок внешних API**

   Проблема заключалась в том, что при обращении бота к внешним сервисам
   могли возникать различные ошибки (например, 400, 401, 404),
   и их нужно было корректно обрабатывать, чтобы информировать пользователя о
   проблеме и предпринимать соответствующие действия. 

   Проект имеет как минимум 2 микросервиса, которые могут выкидывать
   одни и те же HTTP-коды. И в зависимости от определённого кода необходимо
   переводить пользователя к нужному сценарию диалога с сохранением
   предыдущего состояния.
    
   #### Решение

   - Создал файл [errors.py](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/services/errors.py#L6): 
    
       В этом файле определил словарь ERRORS, где сопоставил коды ошибок с 
       ключом словаря в теле ответа, который генерируется при ошибках и 
       состояниями бота, в которые нужно вернуть пользователя при указанной ошибке.
   - Реализовал обработку ошибок в [tasks.py](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/handlers/tasks.py#L42): 
   
     Создал функцию `global_error_handler`, которая принимает событие 
     ошибки и текущий сценарий диалога, в котором находится пользователь.
     В зависимости от того, было ли передано состояние в ошибке `APIError`, 
     пользователь либо остаётся в текущем диалоге, либо переходит в 
     назначенный с передачей всех данных прежнего диалога.


2. **Управление состояниями при создании и редактировании задач**
   
   Проблема заключалась в том, чтобы обеспечить последовательное взаимодействие с пользователем 
   при создании и редактировании задач, отслеживая его ответы и переходя 
   между различными этапами процесса.

   По сценарию диалога процесс создания и редактирования выглядит схоже: 
   пользователь переходит в [состояние выбора полей для изменения](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/dialogs/tasks.py#L68). Но боту в 
   таком случае нужно знать, что в данный момент хочет делать клиент: 
   создать новую / отредактировать уже существующую задачу.

   #### Решение

    - Существующая задача извлекается по id задачи, который передаётся в 
      качестве параметра команды /start бота. Таким образом, при наличии 
      подобного id мы можем судить, какое действие хочет произвести клиент. 
      Дополнительно, добавляем логический параметр в диалог, говорящий об этом.
   
      Подробнее: функция [_fetch_or_initialize_task](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/handlers/tasks.py#L137)
    - При изменении каждого доступного поля задачи вызывается функция 
      [save_task_field](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/handlers/tasks.py#L192), которая по наличию вышеназванных признаков в диалоге,
      определяет: отправить POST-запрос к API / PATCH- для изменения. 
      
      Все данные, введённые в результате перехода в состояние 
      [EDIT_FIELD_SELECTION](https://github.com/Gricana/todo_bot_microservice/blob/f3bc7e2a9f5fae9c730b340e51c938ed3bad26c7/bot/dialogs/tasks.py#L68) 
      сохраняются поверх основного ключа, по которому 
      может храниться уже существующая задача. Так не составит труда 
      передать в API только изменённые данные.

   В результате был отлажен процесс синхронизации данных между разными 
   состояними диалога.
